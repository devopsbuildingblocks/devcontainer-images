name: Build and Push DevContainer Images

on:
  push:
    tags:
      - '*/[0-9]*'      # Matches image-name/0.4.5 or image-name/v0.4.5
      - '*/v[0-9]*'
  workflow_dispatch:
    inputs:
      image_tag:
        description: 'Image tag to build (e.g., ubuntu-base/0.4.5)'
        required: true
        type: string

# Prevent duplicate runs for the same tag
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: false

permissions:
  contents: read
  packages: write

jobs:
  # --------------------------------------------------------------------------------
  # PRIORITIZATION JOB
  # Parses the git tag, discovers all images, detects dependencies, and builds
  # a dynamic priority-based matrix for building in correct order
  # --------------------------------------------------------------------------------
  prioritize:
    runs-on: ubuntu-latest
    outputs:
      target_image: ${{ steps.parse.outputs.target_image }}
      target_version: ${{ steps.parse.outputs.target_version }}
      priorities: ${{ steps.organize.outputs.priorities }}
      max_priority: ${{ steps.organize.outputs.max_priority }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Parse Git Tag
        id: parse
        shell: bash
        run: |
          # Extract tag from ref or workflow_dispatch input
          if [ -n "${{ inputs.image_tag }}" ]; then
            TAG_NAME="${{ inputs.image_tag }}"
          else
            TAG_NAME=${GITHUB_REF#refs/tags/}
          fi
          echo "Full tag: $TAG_NAME"

          # Validate tag format (must contain a slash)
          if [[ ! "$TAG_NAME" =~ / ]]; then
            echo "ERROR: Tag format must be 'image-name/version' (e.g., ubuntu-base/0.4.5)"
            echo "Got: $TAG_NAME"
            exit 1
          fi

          # Split on first '/' to get image name and version
          IMAGE_NAME=$(echo "$TAG_NAME" | cut -d'/' -f1)
          VERSION=$(echo "$TAG_NAME" | cut -d'/' -f2-)

          # Remove 'v' prefix if present
          VERSION=${VERSION#v}

          echo "target_image=$IMAGE_NAME" >> $GITHUB_OUTPUT
          echo "target_version=$VERSION" >> $GITHUB_OUTPUT
          echo "Target image: $IMAGE_NAME"
          echo "Target version: $VERSION"

      - name: Discover Images and Dependencies
        id: discover
        shell: bash
        env:
          REGISTRY: ghcr.io
          REPO_OWNER: ${{ github.repository_owner }}
          REPO_NAME: ${{ github.event.repository.name }}
        run: |
          # Auto-discover all images in src/ directory and their dependencies
          echo "Discovering images in src/ directory..."

          IMAGES_JSON="[]"

          for dir in src/*/; do
            if [ ! -d "$dir" ]; then
              continue
            fi

            IMAGE_NAME=$(basename "$dir")

            echo "Processing $IMAGE_NAME..."
            DEPENDS_ON=""

            # Method 1: Check devcontainer.json for image reference
            for devcontainer in "$dir/.devcontainer.json" "$dir/.devcontainer/devcontainer.json"; do
              if [ -f "$devcontainer" ]; then
                IMAGE_REF=$(jq -r '.image // empty' "$devcontainer" 2>/dev/null || echo "")
                if [ -n "$IMAGE_REF" ]; then
                  # Extract image name from registry path
                  # e.g., ghcr.io/owner/repo/ubuntu-base:latest -> ubuntu-base
                  # Remove everything up to and including the last slash, then remove tag
                  EXTRACTED="${IMAGE_REF##*/}"  # Get last path segment
                  EXTRACTED="${EXTRACTED%%:*}"   # Remove tag if present
                  # Verify it exists in src/ and matches our repo pattern
                  if [ -d "src/$EXTRACTED" ] && echo "$IMAGE_REF" | grep -q "$REGISTRY/$REPO_OWNER/$REPO_NAME"; then
                    DEPENDS_ON="$EXTRACTED"
                    echo "  Found dependency via devcontainer.json: $DEPENDS_ON"
                    break
                  fi
                fi
              fi
            done

            # Method 2: Check Dockerfile for FROM statement
            if [ -z "$DEPENDS_ON" ]; then
              for dockerfile in "$dir/.devcontainer/Dockerfile" "$dir/Dockerfile"; do
                if [ -f "$dockerfile" ]; then
                  # Look for FROM statements referencing our registry
                  FROM_LINE=$(grep "^FROM" "$dockerfile" | grep "$REGISTRY/$REPO_OWNER/$REPO_NAME" | head -1 || true)
                  if [ -n "$FROM_LINE" ]; then
                    # Extract image name from FROM line
                    # e.g., FROM ghcr.io/owner/repo/ubuntu-base:latest -> ubuntu-base
                    IMAGE_PART=$(echo "$FROM_LINE" | awk '{print $2}')
                    EXTRACTED="${IMAGE_PART##*/}"  # Get last path segment
                    EXTRACTED="${EXTRACTED%%:*}"   # Remove tag if present
                    if [ -d "src/$EXTRACTED" ]; then
                      DEPENDS_ON="$EXTRACTED"
                      echo "  Found dependency via Dockerfile: $DEPENDS_ON"
                      break
                    fi
                  fi
                fi
              done
            fi

            # Build JSON entry
            IMAGE_OBJ="{\"name\":\"$IMAGE_NAME\",\"path\":\"src/$IMAGE_NAME\""
            if [ -n "$DEPENDS_ON" ]; then
              IMAGE_OBJ="$IMAGE_OBJ,\"depends_on\":\"$DEPENDS_ON\""
            fi
            IMAGE_OBJ="$IMAGE_OBJ}"

            IMAGES_JSON=$(echo "$IMAGES_JSON" | jq -c ". + [$IMAGE_OBJ]")
          done

          {
            echo "images_json<<EOF"
            echo "$IMAGES_JSON"
            echo "EOF"
          } >> "$GITHUB_OUTPUT"

          echo "Discovered images:"
          echo "$IMAGES_JSON" | jq .

      - name: Check for Concurrent Parent Builds
        id: check_concurrent
        shell: bash
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITHUB_REPOSITORY: ${{ github.repository }}
          TARGET_IMAGE: ${{ steps.parse.outputs.target_image }}
          TARGET_VERSION: ${{ steps.parse.outputs.target_version }}
          IMAGES_JSON: ${{ steps.discover.outputs.images_json }}
        run: |
          # Check if any parent images are currently being built in other workflow runs
          # If so, we need to include them in our priority queue to ensure proper ordering

          ALL_IMAGES=$(echo "$IMAGES_JSON" | jq -c '.')

          # Walk up dependency chain to find parent images referenced in Dockerfiles
          TO_BUILD=("$TARGET_IMAGE")
          CURRENT="$TARGET_IMAGE"

          echo "Checking for parent dependencies of $TARGET_IMAGE..."

          while true; do
            # Find dependency from discovered images
            PARENT=$(echo "$ALL_IMAGES" | jq -r ".[] | select(.name == \"$CURRENT\") | .depends_on // empty")
            if [ -z "$PARENT" ]; then
              break
            fi

            echo "Found dependency: $CURRENT -> $PARENT"

            # Check if there's an active workflow run building this parent
            echo "Checking for active builds of $PARENT..."

            # Use GitHub API to check for in-progress workflow runs
            # head_branch for tag-triggered runs is just the tag name (e.g., "ubuntu-base/0.1.0")
            echo "  Searching for workflows with head_branch starting with: $PARENT/"

            ACTIVE_RUNS=$(gh api \
              "/repos/$GITHUB_REPOSITORY/actions/runs" \
              --method GET \
              -F status=in_progress \
              -F event=push \
              --jq ".workflow_runs[] | select(.name == \"Build and Push DevContainer Images\") | select(.head_branch | startswith(\"$PARENT/\")) | .head_branch" \
              2>&1 || echo "")

            echo "  API response: '$ACTIVE_RUNS'"

            # Also check queued runs that haven't started yet
            QUEUED_RUNS=$(gh api \
              "/repos/$GITHUB_REPOSITORY/actions/runs" \
              --method GET \
              -F status=queued \
              -F event=push \
              --jq ".workflow_runs[] | select(.name == \"Build and Push DevContainer Images\") | select(.head_branch | startswith(\"$PARENT/\")) | .head_branch" \
              2>&1 || echo "")

            echo "  Queued runs: '$QUEUED_RUNS'"

            if [ -n "$ACTIVE_RUNS" ] || [ -n "$QUEUED_RUNS" ]; then
              echo "  ✓ Found concurrent build for $PARENT"
              TO_BUILD+=("$PARENT")
              CURRENT="$PARENT"
            else
              echo "  ✗ No concurrent build found for $PARENT - assuming it exists in registry"
              break
            fi
          done

          # Clean up TO_BUILD elements to remove any accidental whitespace
          for i in "${!TO_BUILD[@]}"; do
            TO_BUILD[$i]=$(echo "${TO_BUILD[$i]}" | tr -d '[:space:]')
          done

          # Export list of images to build as JSON array
          # Manual construction to ensure compact JSON and avoid jq formatting issues
          IMAGES_JSON="["
          for i in "${!TO_BUILD[@]}"; do
            if [ $i -gt 0 ]; then
              IMAGES_JSON="${IMAGES_JSON},"
            fi
            IMAGES_JSON="${IMAGES_JSON}\"${TO_BUILD[$i]}\""
          done
          IMAGES_JSON="${IMAGES_JSON}]"

          {
            echo "images_to_build<<EOF"
            echo "$IMAGES_JSON"
            echo "EOF"
          } >> "$GITHUB_OUTPUT"

          echo "Images to build: ${TO_BUILD[@]}"
          echo "JSON output: ${IMAGES_JSON}"

      - name: Organize into Build Priorities
        id: organize
        shell: bash
        env:
          TARGET_IMAGE: ${{ steps.parse.outputs.target_image }}
          TARGET_VERSION: ${{ steps.parse.outputs.target_version }}
          IMAGES_JSON: ${{ steps.discover.outputs.images_json }}
          IMAGES_TO_BUILD: ${{ steps.check_concurrent.outputs.images_to_build }}
        run: |
          # Organize images into priority queue based on dependencies
          # Priority 0 = base images (no dependencies)
          # Priority N = depends on images at priority N-1

          ALL_IMAGES=$(echo "$IMAGES_JSON" | jq -c '.')
          TO_BUILD=($(echo "$IMAGES_TO_BUILD" | jq -r '.[]'))

          if [ ${#TO_BUILD[@]} -eq 1 ]; then
            echo "Only building target image - no concurrent parent builds detected"

            IMAGE_INFO=$(echo "$ALL_IMAGES" | jq -c ".[] | select(.name == \"$TARGET_IMAGE\")")
            IMAGE_WITH_META=$(echo "$IMAGE_INFO" | jq -c ". + {version: \"$TARGET_VERSION\", is_target: true}")

            PRIORITIES=$(jq -n --argjson img "[$IMAGE_WITH_META]" '{priority0: $img}')
            MAX_PRIORITY=0
          else
            echo "Building dependency chain with ${#TO_BUILD[@]} images"

            # Assign priority numbers based on dependency depth
            declare -A IMAGE_PRIORITIES
            declare -A PRIORITY_IMAGES

            # Function to calculate priority recursively
            function get_priority() {
              local img=$1
              if [ -n "${IMAGE_PRIORITIES[$img]}" ]; then
                echo "${IMAGE_PRIORITIES[$img]}"
                return
              fi

              local dep=$(echo "$ALL_IMAGES" | jq -r ".[] | select(.name == \"$img\") | .depends_on // empty")
              if [ -z "$dep" ]; then
                IMAGE_PRIORITIES[$img]=0
                echo "0"
              else
                local dep_priority=$(get_priority "$dep")
                local img_priority=$((dep_priority + 1))
                IMAGE_PRIORITIES[$img]=$img_priority
                echo "$img_priority"
              fi
            }

            # Calculate priorities for all images in build chain
            for img in "${TO_BUILD[@]}"; do
              priority=$(get_priority "$img")
              echo "  $img -> Priority $priority"

              # Add to priority array
              if [ -z "${PRIORITY_IMAGES[$priority]}" ]; then
                PRIORITY_IMAGES[$priority]="[]"
              fi

              IMAGE_INFO=$(echo "$ALL_IMAGES" | jq -c ".[] | select(.name == \"$img\")")
              IS_TARGET="false"
              if [ "$img" = "$TARGET_IMAGE" ]; then
                IS_TARGET="true"
              fi

              IMAGE_WITH_META=$(echo "$IMAGE_INFO" | jq -c ". + {version: \"$TARGET_VERSION\", is_target: $IS_TARGET}")
              PRIORITY_IMAGES[$priority]=$(echo "${PRIORITY_IMAGES[$priority]}" | jq -c ". + [$IMAGE_WITH_META]")
            done

            # Build final priorities JSON
            MAX_PRIORITY=0
            PRIORITIES="{}"

            for priority in $(echo "${!PRIORITY_IMAGES[@]}" | tr ' ' '\n' | sort -n); do
              PRIORITIES=$(echo "$PRIORITIES" | jq -c --arg key "priority$priority" --argjson val "${PRIORITY_IMAGES[$priority]}" '. + {($key): $val}')
              MAX_PRIORITY=$priority
            done
          fi

          # Display summary
          echo "Build configuration:"
          echo "$PRIORITIES" | jq .

          # Set outputs
          PRIORITIES_COMPACT=$(echo "$PRIORITIES" | jq -c . | jq -Rs .)
          echo "priorities=$PRIORITIES_COMPACT" >> "$GITHUB_OUTPUT"
          echo "max_priority=$MAX_PRIORITY" >> "$GITHUB_OUTPUT"

  # --------------------------------------------------------------------------------
  # DYNAMIC BUILD JOBS
  # Uses dynamic priorities calculated in prioritize job
  # Each priority level waits for the previous priority to complete
  # Priority 0 = highest priority (no dependencies)
  # --------------------------------------------------------------------------------
  priority-0:
    needs: prioritize
    if: fromJson(fromJson(needs.prioritize.outputs.priorities)).priority0[0] != null
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        include: ${{ fromJson(fromJson(needs.prioritize.outputs.priorities)).priority0 }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - uses: ./.github/actions/build-push-devcontainer
        with:
          image_name: ${{ matrix.name }}
          image_folder: ${{ matrix.path }}
          target_version: ${{ matrix.version }}
          is_target: ${{ matrix.is_target }}
          repo_owner: ${{ github.repository_owner }}
          repo_name: ${{ github.event.repository.name }}
          token: ${{ secrets.GITHUB_TOKEN }}

  priority-1:
    needs: [prioritize, priority-0]
    if: fromJson(fromJson(needs.prioritize.outputs.priorities)).priority1[0] != null
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        include: ${{ fromJson(fromJson(needs.prioritize.outputs.priorities)).priority1 }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - uses: ./.github/actions/build-push-devcontainer
        with:
          image_name: ${{ matrix.name }}
          image_folder: ${{ matrix.path }}
          target_version: ${{ matrix.version }}
          is_target: ${{ matrix.is_target }}
          repo_owner: ${{ github.repository_owner }}
          repo_name: ${{ github.event.repository.name }}
          token: ${{ secrets.GITHUB_TOKEN }}

  priority-2:
    needs: [prioritize, priority-1]
    if: fromJson(fromJson(needs.prioritize.outputs.priorities)).priority2[0] != null
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        include: ${{ fromJson(fromJson(needs.prioritize.outputs.priorities)).priority2 }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - uses: ./.github/actions/build-push-devcontainer
        with:
          image_name: ${{ matrix.name }}
          image_folder: ${{ matrix.path }}
          target_version: ${{ matrix.version }}
          is_target: ${{ matrix.is_target }}
          repo_owner: ${{ github.repository_owner }}
          repo_name: ${{ github.event.repository.name }}
          token: ${{ secrets.GITHUB_TOKEN }}

  priority-3:
    needs: [prioritize, priority-2]
    if: fromJson(fromJson(needs.prioritize.outputs.priorities)).priority3[0] != null
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        include: ${{ fromJson(fromJson(needs.prioritize.outputs.priorities)).priority3 }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - uses: ./.github/actions/build-push-devcontainer
        with:
          image_name: ${{ matrix.name }}
          image_folder: ${{ matrix.path }}
          target_version: ${{ matrix.version }}
          is_target: ${{ matrix.is_target }}
          repo_owner: ${{ github.repository_owner }}
          repo_name: ${{ github.event.repository.name }}
          token: ${{ secrets.GITHUB_TOKEN }}

  priority-4:
    needs: [prioritize, priority-3]
    if: fromJson(fromJson(needs.prioritize.outputs.priorities)).priority4[0] != null
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        include: ${{ fromJson(fromJson(needs.prioritize.outputs.priorities)).priority4 }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - uses: ./.github/actions/build-push-devcontainer
        with:
          image_name: ${{ matrix.name }}
          image_folder: ${{ matrix.path }}
          target_version: ${{ matrix.version }}
          is_target: ${{ matrix.is_target }}
          repo_owner: ${{ github.repository_owner }}
          repo_name: ${{ github.event.repository.name }}
          token: ${{ secrets.GITHUB_TOKEN }}
